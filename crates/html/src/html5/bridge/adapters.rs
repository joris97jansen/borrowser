//! Legacy adapters and patch emission bridge.
//!
//! This module adapts HTML5 tree builder output to the legacy DomPatch pipeline.
//! It is intentionally minimal and does not change patch semantics; it only
//! validates lightweight invariants and buffers patches for the runtime.

use crate::dom_patch::{DomPatch, PatchKey};
use crate::html5::tree_builder::PatchSink;
#[cfg(debug_assertions)]
use std::collections::HashSet;

/// Patch emitter adapter for the HTML5 tree builder.
///
/// Mapping rules (skeleton contract):
/// - Patch keys are generated by the HTML5 tree builder and are passed through
///   unchanged. This adapter does not remap or re-allocate keys.
/// - `DomPatch::Clear` may only appear as the first patch in a batch. A violation
///   is treated as an engine invariant error by the session layer.
/// - Ordering/uniqueness invariants (e.g., create-before-attach, no duplicate
///   creates for the same key within a batch) are guaranteed by the tree builder
///   once implemented. This adapter keeps validation lightweight; it currently
///   performs debug-only checks for obvious issues (e.g., duplicate creates within
///   a batch).
/// - Versioning and flush boundaries are owned by the runtime (e.g. runtime_parse);
///   this adapter only buffers patches emitted during a pump.
#[derive(Debug, Default)]
pub(crate) struct PatchEmitterAdapter {
    patches: Vec<DomPatch>,
    saw_clear: bool,
    invariant_violation: bool,
    #[cfg(debug_assertions)]
    created_keys: HashSet<PatchKey>,
}

impl PatchEmitterAdapter {
    pub(crate) fn new() -> Self {
        Self::default()
    }

    pub(crate) fn take_patches(&mut self) -> Vec<DomPatch> {
        // Batch boundaries are defined by session pump + take_patches calls.
        self.saw_clear = false;
        #[cfg(debug_assertions)]
        {
            self.created_keys.clear();
        }
        std::mem::take(&mut self.patches)
    }

    pub(crate) fn take_invariant_violation(&mut self) -> bool {
        let had = self.invariant_violation;
        self.invariant_violation = false;
        #[cfg(debug_assertions)]
        if had {
            self.created_keys.clear();
        }
        had
    }
}

impl PatchSink for PatchEmitterAdapter {
    fn push(&mut self, patch: DomPatch) {
        if matches!(patch, DomPatch::Clear) {
            if !self.patches.is_empty() || self.saw_clear {
                self.invariant_violation = true;
            }
            self.saw_clear = true;
        }
        #[cfg(debug_assertions)]
        {
            if let Some(key) = created_key(&patch) {
                if !self.created_keys.insert(key) {
                    self.invariant_violation = true;
                }
            }
        }
        self.patches.push(patch);
    }
}

#[cfg(debug_assertions)]
fn created_key(patch: &DomPatch) -> Option<PatchKey> {
    match patch {
        DomPatch::CreateDocument { key, .. }
        | DomPatch::CreateElement { key, .. }
        | DomPatch::CreateText { key, .. }
        | DomPatch::CreateComment { key, .. } => Some(*key),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::PatchEmitterAdapter;
    use crate::dom_patch::{DomPatch, PatchKey};
    use crate::html5::tree_builder::PatchSink;

    #[test]
    fn adapter_flags_clear_not_first() {
        let mut adapter = PatchEmitterAdapter::new();
        adapter.push(DomPatch::CreateText {
            key: PatchKey(1),
            text: "x".into(),
        });
        adapter.push(DomPatch::Clear);
        assert!(adapter.take_invariant_violation());
    }

    #[test]
    fn adapter_flags_duplicate_create() {
        let mut adapter = PatchEmitterAdapter::new();
        adapter.push(DomPatch::CreateText {
            key: PatchKey(1),
            text: "x".into(),
        });
        adapter.push(DomPatch::CreateText {
            key: PatchKey(1),
            text: "y".into(),
        });
        assert!(adapter.take_invariant_violation());
    }
}
